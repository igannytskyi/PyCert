import os
import requests
import json
from requests.auth import HTTPBasicAuth
from concurrent.futures import ThreadPoolExecutor

# Set up your Jira URL and authentication
JIRA_URL = "https://your-jira-instance.atlassian.net"
USERNAME = "your-username"  # Jira username
PASSWORD = "your-password"  # Jira password (using basic authentication)
AUTH = HTTPBasicAuth(USERNAME, PASSWORD)

# Function to get the attachment folder (split by groups of 500 files)
def get_attachment_folder():
    base_folder = "./attachments"
    if not os.path.exists(base_folder):
        os.makedirs(base_folder)

    # Get a list of existing folders and check how many files are in each folder
    folders = [f.path for f in os.scandir(base_folder) if f.is_dir()]
    folders.sort()  # Sort folders by name
    if not folders:
        folder_name = "folder_1"
    else:
        folder_name = f"folder_{len(folders) + 1}"

    folder_path = os.path.join(base_folder, folder_name)
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    
    # Check the number of files in the folder, and if it exceeds 500, create a new folder
    current_files = len([f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))])
    if current_files >= 500:
        folder_name = f"folder_{len(folders) + 2}"
        folder_path = os.path.join(base_folder, folder_name)
        os.makedirs(folder_path)

    return folder_path

# Function to download an attachment using Jira's metadata API
def download_attachment(issue_key, attachment_id, filename):
    """Download an attachment from Jira using the attachment API and save it."""
    try:
        # Construct the API URL to get attachment metadata for the specific attachment
        metadata_url = f"{JIRA_URL}/rest/api/2/issue/{issue_key}/attachments/{attachment_id}"

        # Make a GET request to fetch attachment metadata
        response = requests.get(metadata_url, auth=AUTH, headers={"Accept": "application/json"}, verify=False)
        response.raise_for_status()

        # Extract the 'content' URL which contains the actual file URL
        attachment_metadata = response.json()
        file_url = attachment_metadata["content"]

        # Download the attachment using the 'content' URL
        headers = {
            "Accept": "application/octet-stream",  # Force raw file download
            "X-Atlassian-Token": "no-check"
        }

        file_response = requests.get(file_url, auth=AUTH, headers=headers, stream=True, verify=False)
        file_response.raise_for_status()

        # Save the attachment
        folder = get_attachment_folder()  # Ensure the folder path is set correctly
        filepath = os.path.join(folder, filename)

        with open(filepath, "wb") as f:
            for chunk in file_response.iter_content(chunk_size=8192):
                f.write(chunk)

        print(f"✅ Downloaded: {filename}")
        return filepath
    except requests.RequestException as e:
        print(f"❌ Failed to download {filename}: {e}")
        return None

# Function to export all issues from a project
def export_issues(project_key):
    """Export all issues from a Jira project, including attachments and comments."""
    try:
        # Jira REST API endpoint for getting issues
        jql_url = f"{JIRA_URL}/rest/api/2/search"
        query = {
            'jql': f'project={project_key}',
            'fields': 'summary,description,comment,attachments',
            'maxResults': 1000,  # Adjust based on the number of issues you want to fetch at once
        }

        # Make the GET request to fetch the issues
        response = requests.get(jql_url, auth=AUTH, params=query, headers={"Accept": "application/json"}, verify=False)
        response.raise_for_status()

        issues = response.json()['issues']
        print(f"Found {len(issues)} issues in project {project_key}")

        # Prepare to download attachments concurrently using threading
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            
            # Iterate over each issue and process attachments and comments
            for issue in issues:
                issue_key = issue['key']
                issue_fields = issue['fields']
                filename = f"{issue_key}.json"

                # Prepare the issue data to export
                issue_data = {
                    "key": issue_key,
                    "summary": issue_fields.get('summary'),
                    "description": issue_fields.get('description'),
                    "comments": []
                }

                # Handle comments
                comments_url = f"{JIRA_URL}/rest/api/2/issue/{issue_key}/comment"
                comments_response = requests.get(comments_url, auth=AUTH, headers={"Accept": "application/json"}, verify=False)
                comments_response.raise_for_status()

                comments = comments_response.json()['comments']
                for comment in comments:
                    issue_data['comments'].append({
                        'author': comment['author']['displayName'],
                        'body': comment['body']
                    })

                # Handle attachments
                if 'attachments' in issue_fields:
                    for attachment in issue_fields['attachments']:
                        attachment_id = attachment['id']
                        attachment_filename = attachment['filename']

                        # Download the attachment using threading
                        futures.append(executor.submit(download_attachment, issue_key, attachment_id, attachment_filename))
                    
                        # Add the attachment to the issue data (path where it is saved)
                        issue_data.setdefault('attachments', []).append(attachment_filename)

                # Save the issue data to a file (JSON format)
                folder = get_attachment_folder()
                filepath = os.path.join(folder, filename)

                with open(filepath, 'w') as json_file:
                    json.dump(issue_data, json_file, indent=4)

                print(f"✅ Exported issue: {issue_key}")

            # Wait for all downloads to complete
            for future in futures:
                future.result()  # This will block until the download is finished

    except requests.RequestException as e:
        print(f"❌ Failed to export issues: {e}")

# Example Usage: Export issues from a specific Jira project
export_issues('PROJECT_KEY')  # Replace 'PROJECT_KEY' with your Jira project key
